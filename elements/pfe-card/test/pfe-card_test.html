<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="/components/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src="/components/web-component-tester/browser.js"></script>
    <script type="module" src="../pfe-card.js"></script>
  </head>
  <body>

    <pfe-card id="card1">
      <h2 slot="pfe-card--header">Card 1</h2>
      <p>This is pfe-card.</p>
      <div slot="pfe-card--footer">Text in footer</div>
    </pfe-card>

    <script>
      const card = [...document.querySelectorAll("pfe-card")];

      // Returns the luminance value from rgb
      const luminance = (r, g, b) => {
        return (0.2126*r/255 + 0.7152*g/255 + 0.0722*b/255);
      }
      // Converts a hex value to RGBA
      const hexToRgb = hex => {
        const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/.exec(hex);
          return [
              parseInt(r, 16),
              parseInt(g, 16),
              parseInt(b, 16)
           ];
      };
      // Gets the rgba value from an element
      const getColor = (el, prop) => {
        const [, r, g, b] = getComputedStyle(el, null)[prop].match(/rgba?\((\d+),\s+(\d+),\s+(\d+).*\)/)
          .map(n => +n);
        return [r, g, b];
      };

      // Themes and their expected hex values
      const colors = {
        base: "#dfdfdf",
        dark: "#464646",
        darker: "#464646",
        darkest: "#131313",
        accent: "#fe460d",
        complement: "#0477a4",
        light: "#ececec",
        lighter: "#ececec",
        lightest: "#ffffff"
      };

      const slots = {
        header: {
          name: "pfe-card--header",
          class: "pfe-card__header",
          content: "Card 1"
        },
        body: {
          class: "pfe-card__body",
          content: "This is pfe-card."
        },
        footer: {
          name: "pfe-card--footer",
          class: "pfe-card__footer",
          content: "Text in footer"
        }
      };

      suite("<pfe-card>", () => {
        test("it should upgrade", () => {
          assert.instanceOf(
            document.querySelector("pfe-card"),
            customElements.get("pfe-card"),
            "the <pfe-card> should be an instance of PfeCard"
          );
        });

        // Iterate over the colors object to test expected background color results
        Object.entries(colors).forEach(set => {
          test(`it should have a background color of ${set[1]} when pfe-color is ${set[0]}`, () => {
            // If this is not the default theme, update the color attribute
            if(set[0] !== "default") {
              card[0].setAttribute("pfe-color", set[0]);
            }
            // Get the background color value
            const [r, g, b] = getColor(card[0], "background-color");
            // Test that the color is rendering as expected
            assert.deepEqual([r, g, b], hexToRgb(set[1]));
            // Test that the theme is working
            if(["dark", "darker", "darkest", "complement", "accent"].includes(set[0])) {
              assert.isBelow(luminance(r, g, b), 0.5);
            }
            else {
              assert.isAbove(luminance(r, g, b), 0.5);
            }
          });
        });

        test("it should have standard padding when pfe-size is not set", () => {
          assert.equal(getComputedStyle(card[0], null)["padding"], "32px");
        });

        test("it should have reduced padding when pfe-size is small", () => {
          card[0].setAttribute("pfe-size", "small");
          assert.equal(getComputedStyle(card[0], null)["padding"], "16px");
        });

        // Iterate over the slots object to test expected results
        Object.entries(slots).forEach(slot => {
          test(`${slot[0]} content is placed into correct slot`, () => {
            let selector = slot[0] !== "body" ? `[slot=${slot[1].name}]` : "p";
            assert.equal(
              card[0].querySelector(selector).assignedSlot,
              card[0].shadowRoot.querySelector(`.${slot[1].class}`)
            );

            const content = card[0].shadowRoot
              .querySelector(`.${slot[1].class}`)
              .assignedNodes()
              .map(n => n.textContent)
              .join("")
              .trim();
            assert.equal(content, slot[1].content);
          });
        });
      });
    </script>
  </body>
</html>
