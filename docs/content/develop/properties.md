+++
title = "Define properties"
description = ""
weight = 45
draft = false
bref = ""
toc = true
menu = "develop"
tags = [ "develop" ]
+++

TODO review the whole article to ensure the terms "property", "property definition", and "attribute" are all used appropriately.

Property definitions provide a standard, streamlined way to maintain state within your component, receive external input (via attributes), initialize values, trigger handler functions, and more.

## Introduction

To introduce the topic, consider a "Counter" component that counts how many times something has happened.  Such a component could define a counter like this.

```javascript
static get properties() {
  return {
    count: {
      type: Number,
      default: 0
    }
  };
}
```

Defining `count` in this way brightens your day in the following ways:

 - **A property**: The property's name is `count`, so `this.count` is created and initialized to the default value, the number `0`.  
 - **An attribute**: An attribute, `pfe-c-count` is also created, and will be kept in sync with `this.count`.  The `pfe-c-` prefix is explained [below](#prefix).

Below, all the options for property definitions are explained.

## Property / attribute binding

As mentioned in the introduction, defining a property also creates an attribute, and the two values are kept in sync.  The attribute name is generated by converting the property name from camelCase into snake-case, and applying a prefix.  For instance, a property named `firstName` results in `first-name` which is then prefixed with `pfe-c-` to form `pfe-c-first-name`.  These behaviors can be configured with [prefix](#prefix) and [attr](#attr).

## observedAttributes & attributeChangedCallback

Property definitions are driven by PFElement's attributeChangedCallback and observedAttributes.  Due to this, any PatternFly Element using property definitions should not define an attributeChangedCallback (use [observer](#observer) instead) or observedAttributes (attributes created by property definitions are automatically observed).

If an element _must_ have a custom `attributeChangedCallback`, it must call `super.attributeChangedCallback(...arguments)` within it.  The best practice is to not provide an `attributeChangedCallback`.


## type

Default: `String`

Values are stored in attributes as Strings, and are cast into their respective types when accessed via the property.  Three property types are supported: String, Number, and Boolean.


### String

For properties with the String type, this is straightforward.  Attribute values are always strings, and so logic is needed to 

```
name: {
  type: String
}
```

Valid values: any string, `null`, and `undefined`.

### Number

```
count: {
  type: Number
}
```

To store a number, create a property definition with `type: Number`.  A Number-typed property and String-typed attribute will be created for you, and kept in sync when either changes.

The Number type supports some special values, described in this table.  Read the table as follows: "when a property's value is `NaN`, the attribute's value is `"NaN"`, and vice versa".

| Property | Attribute |
| --- | --- |
| `NaN` | `"NaN"` |
| `Infinity` | `"Infinity"` |
| `-Infinity` | `"-Infinity"` |
| `undefined` | `"undefined"` |
| `null` | _removes attribute_ |

Examples: `this.count = NaN` (or `Number.NaN`) will result in `pfe-c-count="NaN"`.

Valid values: any Number, `NaN`, `null`, and `undefined`.

#### A note about precision

Precision is limited to 2<sup>53</sup>-1 by JavaScript's built-in Number type.  You may assign a larger number to an attribute (which are Strings and therefore can support arbitrary precision), but if you reference the number via its property, it will be cast to Number and may lose some precision.

JavaScript's built-in Number type is used, so integers -9007199254740991 &le; n &le; 9007199254740991 and floats 5e-324 &le; n &le; 1.7976931348623157e+308 will retain precision.

### Boolean

```
count: {
  type: Boolean
}
```

Boolean attributes behave just like [boolean attributes](https://html.spec.whatwg.org/dev/common-microsyntaxes.html#boolean-attribute) you might be familiar with, like `disabled` or `checked`.  

| Property | Attribute |
| --- | --- |
| `true` | `""` |
| `false` | _removes attribute_ |
| `"hello I am true"` | `""` |
| `undefined` | `"undefined"` |
| `null` | _removes attribute_ |

When referencing a Boolean attribute (when styling a component, for example), 


### Handling `null`

No matter what `type` is specified in the property definition, if a property is assigned to `null`, its associated attribute will be removed.

Example: `this.count = null` will result in the `pfe-c-count` attribute being removed.

## default

Default: `undefined`

During the component's `connectedCallback`, values with defined defaults will be initialized in both properties and attributes.

Example: since `count` has a default of `0`, when the component is connected, it will have `this.count === 0` and `this.getAttribute("pfe-c-count") === "0"`.

## observer

Default: `undefined`

Observers provide a quick way to wire up a function to be called whenever a value changes.

You may provide an `observer` for any property, which is the string name of a (non-static) function inside the web component which will be called whenever the property changes.  Here's an example wherein changes to `count` will trigger the `handleCount` function.

```js
class PfeCount extends PFElement {

  /* some boilerplate omitted */

  static get properties() {
    return {
      count: {
        type: Number,
        observer: "handleCount"
      }
    }
  }

  handleCount(oldVal, newVal) {
    console.log(`count changed from ${oldVal} to ${newVal}`);
  }

}
```

Observer functions are called with arguments `(oldVal, newVal)`.  Like property values, both arguments will be cast to the appropriate type, ie String, Number, or Boolean.


## cascade

Default: `undefined`

`cascade` allows an attribute to be automatically copied to one or more child elements.  The value of `cascade` is a CSS-style selector which is used to match the children that should receive the attribute.  The selector is applied to the element's children in both the light DOM and the shadow DOM.

Example, cascading an attribute `pfe-c-foo` to any `h1`, `h2`, or `h3` child elements.

```
static get properties() {
  return {
    foo: {
      type: String,
      cascade: "h1,h2,h3"
    }
  };
}
```

With cascade, attribute values are only copied from parent to child, never the other way around.

## prefix

PatternFly Elements has a convention of prefixing a component's own attribute names with `pfe-c-`, and the `prefix` field controls that.  Attributes are prefixed by default, but you may set `prefix: false` if you wish your attribute to have no prefix.

This can be useful when depreacting old, non-prefixed attributes, and when creating properties bound to ARIA attributes, or other built-in HTML attributes.

```
static get properties() {
  return {
    ariaHidden: {
      type: String,
      default: "true",
      prefix: false
    }
  };
}
```

The property name `ariaHidden` results in an attribute named `aria-hidden`.  If prefix were not set to false, the generated attribute name would be `pfe-c-aria-hidden` instead.

Note: [ARIA attributes](https://www.w3.org/TR/wai-aria-1.1/#state_prop_def) must be defined as Strings, for even though attributes like `aria-hidden` seem like booleans, they are not true boolean attributes, and they only accept values of `"true"` and `"false"`.

## alias

Default: `undefined`

The `alias` field can be used to link two properties to each other.  `alias` expects to be given the name of another property, to which it will copy its value.  When a property value is changed, if it has an alias, the new value will be sent to the alias.

Aliasing is intended to help when migrating to a new property/attribute name.  It allows for two different properties to be simultaneously "active".

Example, an `old` property whose values will be forwarded along to a `new` property.

```
static get properties() {
  return {
    new: {
      type: Number,
      default: 0,
    },
    old: {
      type: Number,
      alias: "new"
    }
  };
}
```

With these property definitions, changes to `old` will be "forwarded" along to `new`.

```
el.source = 4;
el.destination === 4; // true
```

Two-way aliases are allowed.

```
static get properties() {
  return {
    a: {
      alias: "b"
    },
    b: {
      alias: "a"
    }
  };
}
```

## attr

Default: `undefined`

The `attr` field overrides the property's default attribute name and specifies a custom name to be used as this property's bound attribute.

```
static get properties() {
  return {
    foo: {
      prefix: false,
      attr: "the-one-and-only-foo"
    },
  };
}
```

`attr`, along with `alias`, are primarily intended to help when migrating to a new property/attribute name.  It allows for two different properties to be simultaneously "active".

## title

Default: `undefined`

The `title` field defines a human-friendly title for the property, which will be used to label the property's form fields in the Storybook-powered demo site.

[Move to Step 2: Develop (Develop a Structure)](../step-2a/)
